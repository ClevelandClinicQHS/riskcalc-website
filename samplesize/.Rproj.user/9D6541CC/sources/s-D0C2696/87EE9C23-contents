rct_continuous = function(treat, control, diff, delta, sd, r=1, power, alpha, design = c("Equivalence", "NonInferiority", "Superiority")) {
    design = match.arg(design, c("Equivalence", "NonInferiority", "Superiority"))
    beta = 1 - power
    z.alpha = qnorm(1 - alpha, mean = 0, sd = 1)
    
    if (delta < 0) {
        stop("difference margin must be non-negative")
    }
    
    if (is.na(diff) & !is.na(treat) & !is.na(control)) {
        diff = treat - control
    } else if (is.na(diff)) {
        stop("please specify either mean difference or expected mean in the treatment group and in the control group")
    }
    
    if (design == "NonInferiority") {
        z.beta = qnorm(1 - beta, mean = 0, sd = 1)
        n_c = (1 + 1/r) * (sd * (z.alpha + z.beta) / (diff + delta)) ^ 2
    } else if (design == "Equivalence") {
        z.beta = qnorm(1 - beta / 2, mean = 0, sd = 1)
        n_c = (1 + 1/r) * (sd * (z.alpha + z.beta) / (abs(diff) - delta)) ^ 2
    } else if (design == "Superiority") {
        z.beta = qnorm(1 - beta, mean = 0, sd = 1)
        n_c = (1 + 1/r) * (sd * (z.alpha + z.beta) / (diff - delta)) ^ 2
    } 
    
    # r = n_t/n_c
    n_c = ceiling(n_c)
    n_t = n_c * r
    
    return(list(n_treat = n_t, n_control = n_c, n_total = n_t + n_c))
}

rct_proportion = function(treat, control, OR, delta, delta_exp, r=1, power, alpha, design = c("Equivalence", "NonInferiority", "Superiority")) {
    design = match.arg(design, c("Equivalence", "NonInferiority", "Superiority"))
    beta = 1 - power
    z.alpha = qnorm(1 - alpha, mean = 0, sd = 1)
    
    if (!is.na(delta) & delta < 0) {
        stop("difference margin must be non-negative")
    }
    if (!is.na(delta_exp) & delta_exp < 0) {
        stop("difference margin in exp scale must be non-negative")
    }
    if (!is.na(OR) & (is.na(treat) | is.na(control))) {
        if (is.na(treat) & is.na(control)) {
            control = 0.5
            treat = OR / (1+OR)
        } else if (is.na(treat)) {
            treat = control * OR / (1 - control + control * OR)
        } else if (is.na(control)) {
            control = treat / (OR - OR * treat + treat)
        }
    }
    if (!is.na(delta_exp) & is.na(delta)) {
        delta = abs(log(delta_exp))
    }
    
    if (design == "NonInferiority") {
        z.beta = qnorm(1 - beta, mean = 0, sd = 1)
        n_c = (treat * (1 - treat) / r + control * (1 - control)) * ((z.alpha + z.beta) / (treat - control + delta)) ^ 2
    } else if (design == "Equivalence") {
        z.beta = qnorm(1 - beta, mean = 0, sd = 1)
        n_c = (treat * (1 - treat) / r + control * (1 - control)) * ((z.alpha + z.beta) / (abs(treat - control) - delta)) ^ 2
    } else if (design == "Superiority") {
        z.beta = qnorm(1 - beta, mean = 0, sd = 1)
        n_c = (treat * (1 - treat) / r + control * (1 - control)) * ((z.alpha + z.beta) / (treat - control + delta)) ^ 2
    } 
    
    # r = n_t/n_c
    n_c = ceiling(n_c)
    n_t = n_c * r
    
    return(list(n_treat = n_t, n_control = n_c, n_total = n_t + n_c))
}

rct_survival = function(HR, delta, pi_treat, pi_control, r=1, power, alpha, design = c("equivalence", "non-inferiority", "superiority")) {
    design = match.arg(design, c("equivalence", "non-inferiority", "superiority"))
    beta = 1 - power
    z.alpha = qnorm(1 - alpha, mean = 0, sd = 1)
    
    log_delta = abs(log(delta))
    log_hr = log(HR)
    
    if (design == "non-inferiority") {
        z.beta = qnorm(1 - beta, mean = 0, sd = 1)
        d_c = (r + 1) / r * ((z.alpha + z.beta) / (log_hr + log_delta)) ^ 2
    } else if (design == "equivalence") {
        z.beta = qnorm(1 - beta, mean = 0, sd = 1)
        d_c = (r + 1) / r * ((z.alpha + z.beta) / (abs(log_hr) - log_delta)) ^ 2
    } else if (design == "superiority") {
        z.beta = qnorm(1 - beta, mean = 0, sd = 1)
        d_c = (r + 1) / r * ((z.alpha + z.beta) / (log_hr - log_delta)) ^ 2
    } 
    
    # r = n_t/n_c
    if (!is.na(pi_treat)) {
        pi_treat = 1 - (1-pi_control) ^ HR
    } else if (!is.na(pi_control)) {
        pi_control = 1 - (1-pi_treat) ^ (1/HR)
    } 
    
    d_t = d_c * r
    n_c = ceiling(d_c / pi_control)
    n_t = ceiling(d_t / pi_treat)
    
    return(list(n_treat = n_t, n_control = n_c, n_total = n_treat + n_control))
}

cc = function(p0, p1, OR, r=1, rho=0.2, alpha, power, two.side=T, design = c("matched", "unmatched")) {
    design = match.arg(design,  c("matched", "unmatched"))
    beta = 1 - power
    alpha = ifelse(two.side==T, alpha / 2, alpha)
    z.alpha = qnorm(1 - alpha, mean = 0, sd = 1)
    z.beta = qnorm(1 - beta, mean = 0, sd = 1)
    
    if (design == "unmatched" & !is.na(OR) & (is.na(p1) | is.na(p0))) {
        p0 = 0.5
        p1 = OR / (1 + OR)
    }
    if (design == "matched" & !is.na(OR) & (is.na(p1) | is.na(p0))) {
        a = (1-p0+OR*p0)^2+rho^2*(1-OR)^2*p0*(1-p0)
        b = -2*OR*p0*(1-p0+OR*p0)-rho^2*(1-OR)^2*p0*(1-p0)
        c = OR^2 * p0^2
        case1 = (-b + sqrt(b^2-4*a*c)) / (2*a)
        case2 = (-b - sqrt(b^2-4*a*c)) / (2*a)
        err1 = (case1*(1-p0)-rho*sqrt(case1*p0*(1-case1)*(1-p0)))/(p0*(1-case1)-rho*sqrt(case1*p0*(1-case1)*(1-p0)))-OR
        err2 = (case2*(1-p0)-rho*sqrt(case2*p0*(1-case2)*(1-p0)))/(p0*(1-case2)-rho*sqrt(case2*p0*(1-case2)*(1-p0)))-OR
        if (abs(err1) < 10^-5) p1 = case1
        if (abs(err2) < 10^-5) p1 = case2
    }
    
    if (design == "unmatched") {
        pbar = (r * p0 + p1) / (r + 1)
        Np1 = z.alpha * sqrt((r + 1) * pbar * (1 - pbar))
        Np2 = z.beta * sqrt(p0 * (1 - p0) + r * p1 * (1 - p1))
        n = (Np1 + Np2) ^ 2 / (r * (p1 - p0) ^ 2)
        n_cc = n / 4 * (1 + sqrt(1 + 2 * (r + 1)/(r * n * abs(p1 - p0)))) ^ 2
        n_case = ceiling(n)
        n_case_cc = ceiling(n_cc)
        n_control = r * n_case
        n_control_cc = r * n_case_cc
        return(list(fless.case = n_case, fless.control = n_control, 
                    flesscc.case = n_case_cc, flesscc.control = n_control_cc))
    }
    
    if (design == "matched") {
        psi = OR
        pq = p1 * (1 - p1) * p0 * (1 - p0)
        p0.p = (p1 * p0 + rho * sqrt(pq)) / p1
        p0.n = (p0 * (1 - p1) - rho * sqrt(pq)) / (1 - p1)
        
        tm = ee.psi = ee.one = nu.psi = nu.one = rep(NA, r)
        for(m in 1:r){
            tm[m] <- p1 * choose(r, m - 1) * ((p0.p)^(m - 1)) * ((1 - p0.p)^(r - m + 1)) + (1 - p1) * choose(r,m) * ((p0.n)^m) * ((1 - p0.n))^(r - m)
            ee.psi[m] <- m * tm[m] * psi / (m * psi + r - m + 1)
            ee.one[m] <- m * tm[m] / (r + 1)
            nu.psi[m] <- m * tm[m] * psi * (r - m + 1) / ((m * psi + r - m + 1)^2)
            nu.one[m] <- m * tm[m] * (r - m + 1) / ((r + 1)^2)
        }
        
        ee.psi <- sum(ee.psi)
        ee.one <- sum(ee.one)
        nu.psi <- sum(nu.psi)
        nu.one <- sum(nu.one)
        
        n1 <- ceiling(((z.beta * sqrt(nu.psi) + z.alpha * sqrt(nu.one))^2) / ((ee.one - ee.psi)^2))
        n2 <- ceiling(r * n1)    
        return(list(n.case = n1, n.control=n2))
    }
}

cohort = function(p1, p2, RR, r=1, rho=0.2, alpha, power, two.side=T, design = c("independent", "paired")) {
    design = match.arg(design,  c("independent", "paired"))
    beta = 1 - power
    alpha = ifelse(two.side==T, alpha / 2, alpha)
    z.alpha = qnorm(1 - alpha, mean = 0, sd = 1)
    z.beta = qnorm(1 - beta, mean = 0, sd = 1)
    
    if (!is.na(RR) & !is.na(p1) & is.na(p2)) p2 = RR * p1
    if (!is.na(RR) & !is.na(p2) & is.na(p1)) p1 = p2 / RR
    
    if (design == "independent") {
        pbar = (r * p1 + p2) / (r + 1)
        Np1 = z.alpha * sqrt((r + 1) * pbar * (1 - pbar))
        Np2 = z.beta * sqrt(p1 * (1 - p1) + r * p2 * (1 - p2))
        n = (Np1 + Np2) ^ 2 / (r * (p2 - p1) ^ 2)
        n_cc = n / 4 * (1 + sqrt(1 + 2 * (r + 1)/(r * n * abs(p2 - p1)))) ^ 2
        n_exposed = ceiling(n)
        n_exposed_cc = ceiling(n_cc)
        n_unexposed = r * n_exposed
        n_unexposed_cc = r * n_exposed_cc
        return(list(n_exposed = n_exposed, n_unexposed = n_unexposed,
                    n_exposed_cc = n_exposed_cc, n_unexposed_cc = n_unexposed_cc))
    }
    
    if (design == "paired") {
        pa = p0 * (1-p1) - rho * sqrt(p1 * (1-p1) * p0 * (1-p0))
        pb = p1 * (1-p0) - rho * sqrt(p1 * (1-p1) * p0 * (1-p0))
        pstar = pb / (pa + pb)
        n = (0.5 * z.alpha + z.beta * sqrt(pstar * (1 - pstar))) ^ 2 / (pa * pb * (pstar - 0.5)^2)
        n_exposed = ceiling(n)
        return(list(n_exposed = n_exposed, n_unexposed = n_exposed))
    }
}

cohort_survival = function(p1, p2, HR, t=1, r=1, alpha, power, two.side=T) {
    beta = 1 - power
    alpha = ifelse(two.side==T, alpha / 2, alpha)
    z.alpha = qnorm(1 - alpha, mean = 0, sd = 1)
    z.beta = qnorm(1 - beta, mean = 0, sd = 1)
    
    if (is.na(p1) & is.na(p2) & !is.na(HR) & !is.na(t)) {
        p1 = 1 - exp(-t)
        p2 = 1 - exp(- HR * t)
    }
    n2 = (1 / (r * p1) + 1 / p2) * ((z.alpha + z.beta) / log(HR)) ^ 2
    n2 = ceiling(n1)
    n1 = n2 * r
    return(list(n_exposed=n2, n_unexposed = n1))
}

cross_sectional = function(p1, p2, variance, r=1, alpha, power, two.side=T, design = c("continuous", "proportion")) {
    design = match.arg(design,  c("continuous", "proportion"))
    beta = 1 - power
    alpha = ifelse(two.side==T, alpha / 2, alpha)
    z.alpha = qnorm(1 - alpha, mean = 0, sd = 1)
    z.beta = qnorm(1 - beta, mean = 0, sd = 1)
    
    if (design == "proportion") {
        pbar = (r * p1 + p2) / (r + 1)
        Np1 = z.alpha * sqrt((r + 1) * pbar * (1 - pbar))
        Np2 = z.beta * sqrt(p1 * (1 - p1) + r * p2 * (1 - p2))
        n = (Np1 + Np2) ^ 2 / (r * (p2 - p1) ^ 2)
        n_cc = n / 4 * (1 + sqrt(1 + 2 * (r + 1)/(r * n * abs(p2 - p1)))) ^ 2
        n_exposed = ceiling(n)
        n_exposed_cc = ceiling(n_cc)
        n_unexposed = r * n_exposed
        n_unexposed_cc = r * n_exposed_cc
        return(list(n1 = n_unexposed, n2 = n_exposed,
                    n1_cc = n_unexposed_cc, n2_cc = n_exposed_cc))
    }
    if (design == "continuous") {
        n2 = (1 + 1/r) * variance * ((z.alpha + z.beta) / (p1 - p2))^2
        n2 = ceiling(n2)
        n1 = r * n2
        return(list(n1 = n1, n2 = n2))
    }
}